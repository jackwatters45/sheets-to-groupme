/**
 * @since 0.21.0
 */
import type * as Cause from "effect/Cause";
import * as Either from "effect/Either";
import * as Exit from "effect/Exit";
import * as Option from "effect/Option";
/**
 * Throws an `AssertionError` with the provided error message.
 *
 * @since 0.21.0
 */
export declare function fail(message: string): void;
/**
 * Asserts that `actual` is equal to `expected` using the `Equal.equals` trait.
 *
 * @since 0.21.0
 */
export declare function deepStrictEqual<A>(actual: A, expected: A, message?: string, ..._: Array<never>): void;
/**
 * Asserts that `actual` is not equal to `expected` using the `Equal.equals` trait.
 *
 * @since 0.21.0
 */
export declare function notDeepStrictEqual<A>(actual: A, expected: A, message?: string, ..._: Array<never>): void;
/**
 * Asserts that `actual` is equal to `expected` using the `Equal.equals` trait.
 *
 * @since 0.21.0
 */
export declare function strictEqual<A>(actual: A, expected: A, message?: string, ..._: Array<never>): void;
/**
 * Asserts that `actual` is equal to `expected` using the `Equal.equals` trait.
 *
 * @since 0.21.0
 */
export declare function assertEquals<A>(actual: A, expected: A, message?: string, ..._: Array<never>): void;
/**
 * Asserts that `thunk` does not throw an error.
 *
 * @since 0.21.0
 */
export declare function doesNotThrow(thunk: () => void, message?: string, ..._: Array<never>): void;
/**
 * Asserts that `value` is an instance of `constructor`.
 *
 * @since 0.21.0
 */
export declare function assertInstanceOf<C extends abstract new (...args: any) => any>(value: unknown, constructor: C, message?: string, ..._: Array<never>): asserts value is InstanceType<C>;
/**
 * Asserts that `self` is `true`.
 *
 * @since 0.21.0
 */
export declare function assertTrue(self: unknown, message?: string, ..._: Array<never>): asserts self;
/**
 * Asserts that `self` is `false`.
 *
 * @since 0.21.0
 */
export declare function assertFalse(self: boolean, message?: string, ..._: Array<never>): void;
/**
 * Asserts that `actual` includes `expected`.
 *
 * @since 0.21.0
 */
export declare function assertInclude(actual: string | undefined, expected: string, ..._: Array<never>): void;
/**
 * Asserts that `actual` matches `regexp`.
 *
 * @since 0.21.0
 */
export declare function assertMatch(actual: string, regexp: RegExp, ..._: Array<never>): void;
/**
 * Asserts that `thunk` throws an error.
 *
 * @since 0.21.0
 */
export declare function throws(thunk: () => void, error?: Error | ((u: unknown) => undefined), ..._: Array<never>): void;
/**
 * Asserts that `thunk` throws an error.
 *
 * @since 0.21.0
 */
export declare function throwsAsync(thunk: () => Promise<void>, error?: Error | ((u: unknown) => undefined), ..._: Array<never>): Promise<void>;
/**
 * Asserts that `option` is `None`.
 *
 * @since 0.21.0
 */
export declare function assertNone<A>(option: Option.Option<A>, ..._: Array<never>): asserts option is Option.None<never>;
/**
 * Asserts that `option` is `Some`.
 *
 * @since 0.21.0
 */
export declare function assertSome<A>(option: Option.Option<A>, expected: A, ..._: Array<never>): asserts option is Option.Some<A>;
/**
 * Asserts that `either` is `Left`.
 *
 * @since 0.21.0
 */
export declare function assertLeft<R, L>(either: Either.Either<R, L>, expected: L, ..._: Array<never>): asserts either is Either.Left<L, never>;
/**
 * Asserts that `either` is `Right`.
 *
 * @since 0.21.0
 */
export declare function assertRight<R, L>(either: Either.Either<R, L>, expected: R, ..._: Array<never>): asserts either is Either.Right<never, R>;
/**
 * Asserts that `exit` is a failure.
 *
 * @since 0.21.0
 */
export declare function assertFailure<A, E>(exit: Exit.Exit<A, E>, expected: Cause.Cause<E>, ..._: Array<never>): asserts exit is Exit.Failure<never, E>;
/**
 * Asserts that `exit` is a success.
 *
 * @since 0.21.0
 */
export declare function assertSuccess<A, E>(exit: Exit.Exit<A, E>, expected: A, ..._: Array<never>): asserts exit is Exit.Success<A, never>;
//# sourceMappingURL=utils.d.ts.map