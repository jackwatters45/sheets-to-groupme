import * as Arbitrary from "effect/Arbitrary";
import * as Cause from "effect/Cause";
import * as Duration from "effect/Duration";
import * as Effect from "effect/Effect";
import * as Equal from "effect/Equal";
import * as Exit from "effect/Exit";
import * as fc from "effect/FastCheck";
import * as Fiber from "effect/Fiber";
import { flow, identity, pipe } from "effect/Function";
import * as Layer from "effect/Layer";
import * as Logger from "effect/Logger";
import { isObject } from "effect/Predicate";
import * as Schedule from "effect/Schedule";
import * as Schema from "effect/Schema";
import * as Scope from "effect/Scope";
import * as TestEnvironment from "effect/TestContext";
import * as Utils from "effect/Utils";
import * as V from "vitest";
const defaultApi = /*#__PURE__*/Object.assign(V.it, {
  scopedFixtures: V.it.scoped
});
const runPromise = ctx => effect => Effect.gen(function* () {
  const exitFiber = yield* Effect.fork(Effect.exit(effect));
  ctx?.onTestFinished(() => Fiber.interrupt(exitFiber).pipe(Effect.asVoid, Effect.runPromise));
  const exit = yield* Fiber.join(exitFiber);
  if (Exit.isSuccess(exit)) {
    return () => exit.value;
  } else {
    if (Cause.isInterruptedOnly(exit.cause)) {
      return () => {
        throw new Error("All fibers interrupted without errors.");
      };
    }
    const errors = Cause.prettyErrors(exit.cause);
    for (let i = 1; i < errors.length; i++) {
      yield* Effect.logError(errors[i]);
    }
    return () => {
      throw errors[0];
    };
  }
}).pipe(effect => Effect.runPromise(effect, {
  signal: ctx?.signal
})).then(f => f());
/** @internal */
const runTest = ctx => effect => runPromise(ctx)(effect);
/** @internal */
const TestEnv = /*#__PURE__*/TestEnvironment.TestContext.pipe(/*#__PURE__*/Layer.provide(/*#__PURE__*/Logger.remove(Logger.defaultLogger)));
/** @internal */
function customTester(a, b, customTesters) {
  if (!Equal.isEqual(a) || !Equal.isEqual(b)) {
    return undefined;
  }
  return Utils.structuralRegion(() => Equal.equals(a, b), (x, y) => this.equals(x, y, customTesters.filter(t => t !== customTester)));
}
/** @internal */
export const addEqualityTesters = () => {
  V.expect.addEqualityTesters([customTester]);
};
/** @internal */
const testOptions = timeout => typeof timeout === "number" ? {
  timeout
} : timeout ?? {};
/** @internal */
const makeTester = (mapEffect, it = defaultApi) => {
  const run = (ctx, args, self) => pipe(Effect.suspend(() => self(...args)), mapEffect, runTest(ctx));
  const f = (name, self, timeout) => it(name, testOptions(timeout), ctx => run(ctx, [ctx], self));
  const skip = (name, self, timeout) => it.skip(name, testOptions(timeout), ctx => run(ctx, [ctx], self));
  const skipIf = condition => (name, self, timeout) => it.skipIf(condition)(name, testOptions(timeout), ctx => run(ctx, [ctx], self));
  const runIf = condition => (name, self, timeout) => it.runIf(condition)(name, testOptions(timeout), ctx => run(ctx, [ctx], self));
  const only = (name, self, timeout) => it.only(name, testOptions(timeout), ctx => run(ctx, [ctx], self));
  const each = cases => (name, self, timeout) => it.for(cases)(name, testOptions(timeout), (args, ctx) => run(ctx, [args], self));
  const fails = (name, self, timeout) => V.it.fails(name, testOptions(timeout), ctx => run(ctx, [ctx], self));
  const prop = (name, arbitraries, self, timeout) => {
    if (Array.isArray(arbitraries)) {
      const arbs = arbitraries.map(arbitrary => Schema.isSchema(arbitrary) ? Arbitrary.make(arbitrary) : arbitrary);
      return it(name, testOptions(timeout), ctx =>
      // @ts-ignore
      fc.assert(
      // @ts-ignore
      fc.asyncProperty(...arbs, (...as) => run(ctx, [as, ctx], self)), isObject(timeout) ? timeout?.fastCheck : {}));
    }
    const arbs = fc.record(Object.keys(arbitraries).reduce(function (result, key) {
      result[key] = Schema.isSchema(arbitraries[key]) ? Arbitrary.make(arbitraries[key]) : arbitraries[key];
      return result;
    }, {}));
    return it(name, testOptions(timeout), ctx =>
    // @ts-ignore
    fc.assert(fc.asyncProperty(arbs, (...as) =>
    // @ts-ignore
    run(ctx, [as[0], ctx], self)), isObject(timeout) ? timeout?.fastCheck : {}));
  };
  return Object.assign(f, {
    skip,
    skipIf,
    runIf,
    only,
    each,
    fails,
    prop
  });
};
/** @internal */
export const prop = (name, arbitraries, self, timeout) => {
  if (Array.isArray(arbitraries)) {
    const arbs = arbitraries.map(arbitrary => Schema.isSchema(arbitrary) ? Arbitrary.make(arbitrary) : arbitrary);
    return V.it(name, testOptions(timeout),
    // @ts-ignore
    ctx => fc.assert(fc.property(...arbs, (...as) => self(as, ctx)), isObject(timeout) ? timeout?.fastCheck : {}));
  }
  const arbs = fc.record(Object.keys(arbitraries).reduce(function (result, key) {
    result[key] = Schema.isSchema(arbitraries[key]) ? Arbitrary.make(arbitraries[key]) : arbitraries[key];
    return result;
  }, {}));
  return V.it(name, testOptions(timeout),
  // @ts-ignore
  ctx => fc.assert(fc.property(arbs, as => self(as, ctx)), isObject(timeout) ? timeout?.fastCheck : {}));
};
/** @internal */
export const layer = (layer_, options) => (...args) => {
  const excludeTestServices = options?.excludeTestServices ?? false;
  const withTestEnv = excludeTestServices ? layer_ : Layer.provideMerge(layer_, TestEnv);
  const memoMap = options?.memoMap ?? Effect.runSync(Layer.makeMemoMap);
  const scope = Effect.runSync(Scope.make());
  const runtimeEffect = Layer.toRuntimeWithMemoMap(withTestEnv, memoMap).pipe(Scope.extend(scope), Effect.orDie, Effect.cached, Effect.runSync);
  const makeIt = it => Object.assign(it, {
    effect: makeTester(effect => Effect.flatMap(runtimeEffect, runtime => effect.pipe(Effect.provide(runtime))), it),
    prop,
    scoped: makeTester(effect => Effect.flatMap(runtimeEffect, runtime => effect.pipe(Effect.scoped, Effect.provide(runtime))), it),
    flakyTest,
    layer(nestedLayer, options) {
      return layer(Layer.provideMerge(nestedLayer, withTestEnv), {
        ...options,
        memoMap,
        excludeTestServices
      });
    }
  });
  if (args.length === 1) {
    V.beforeAll(() => runPromise()(Effect.asVoid(runtimeEffect)), options?.timeout ? Duration.toMillis(options.timeout) : undefined);
    V.afterAll(() => runPromise()(Scope.close(scope, Exit.void)), options?.timeout ? Duration.toMillis(options.timeout) : undefined);
    return args[0](makeIt(defaultApi));
  }
  return V.describe(args[0], () => {
    V.beforeAll(() => runPromise()(Effect.asVoid(runtimeEffect)), options?.timeout ? Duration.toMillis(options.timeout) : undefined);
    V.afterAll(() => runPromise()(Scope.close(scope, Exit.void)), options?.timeout ? Duration.toMillis(options.timeout) : undefined);
    return args[1](makeIt(defaultApi));
  });
};
/** @internal */
export const flakyTest = (self, timeout = Duration.seconds(30)) => pipe(Effect.catchAllDefect(self, Effect.fail), Effect.retry(pipe(Schedule.recurs(10), Schedule.compose(Schedule.elapsed), Schedule.whileOutput(Duration.lessThanOrEqualTo(timeout)))), Effect.orDie);
/** @internal */
export const makeMethods = it => Object.assign(it, {
  effect: makeTester(Effect.provide(TestEnv), it),
  scoped: makeTester(flow(Effect.scoped, Effect.provide(TestEnv)), it),
  live: makeTester(identity, it),
  scopedLive: makeTester(Effect.scoped, it),
  flakyTest,
  layer,
  prop
});
/** @internal */
export const {
  /** @internal */
  effect,
  /** @internal */
  live,
  /** @internal */
  scoped,
  /** @internal */
  scopedLive
} = /*#__PURE__*/makeMethods(defaultApi);
/** @internal */
export const describeWrapped = (name, f) => V.describe(name, it => f(makeMethods(Object.assign(it, {
  scopedFixtures: it.scoped
}))));
//# sourceMappingURL=internal.js.map