"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.scopedLive = exports.scoped = exports.prop = exports.makeMethods = exports.live = exports.layer = exports.flakyTest = exports.effect = exports.describeWrapped = exports.addEqualityTesters = void 0;
var Arbitrary = _interopRequireWildcard(require("effect/Arbitrary"));
var Cause = _interopRequireWildcard(require("effect/Cause"));
var Duration = _interopRequireWildcard(require("effect/Duration"));
var Effect = _interopRequireWildcard(require("effect/Effect"));
var Equal = _interopRequireWildcard(require("effect/Equal"));
var Exit = _interopRequireWildcard(require("effect/Exit"));
var fc = _interopRequireWildcard(require("effect/FastCheck"));
var Fiber = _interopRequireWildcard(require("effect/Fiber"));
var _Function = require("effect/Function");
var Layer = _interopRequireWildcard(require("effect/Layer"));
var Logger = _interopRequireWildcard(require("effect/Logger"));
var _Predicate = require("effect/Predicate");
var Schedule = _interopRequireWildcard(require("effect/Schedule"));
var Schema = _interopRequireWildcard(require("effect/Schema"));
var Scope = _interopRequireWildcard(require("effect/Scope"));
var TestEnvironment = _interopRequireWildcard(require("effect/TestContext"));
var Utils = _interopRequireWildcard(require("effect/Utils"));
var V = _interopRequireWildcard(require("vitest"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
const defaultApi = /*#__PURE__*/Object.assign(V.it, {
  scopedFixtures: V.it.scoped
});
const runPromise = ctx => effect => Effect.gen(function* () {
  const exitFiber = yield* Effect.fork(Effect.exit(effect));
  ctx?.onTestFinished(() => Fiber.interrupt(exitFiber).pipe(Effect.asVoid, Effect.runPromise));
  const exit = yield* Fiber.join(exitFiber);
  if (Exit.isSuccess(exit)) {
    return () => exit.value;
  } else {
    if (Cause.isInterruptedOnly(exit.cause)) {
      return () => {
        throw new Error("All fibers interrupted without errors.");
      };
    }
    const errors = Cause.prettyErrors(exit.cause);
    for (let i = 1; i < errors.length; i++) {
      yield* Effect.logError(errors[i]);
    }
    return () => {
      throw errors[0];
    };
  }
}).pipe(effect => Effect.runPromise(effect, {
  signal: ctx?.signal
})).then(f => f());
/** @internal */
const runTest = ctx => effect => runPromise(ctx)(effect);
/** @internal */
const TestEnv = /*#__PURE__*/TestEnvironment.TestContext.pipe(/*#__PURE__*/Layer.provide(/*#__PURE__*/Logger.remove(Logger.defaultLogger)));
/** @internal */
function customTester(a, b, customTesters) {
  if (!Equal.isEqual(a) || !Equal.isEqual(b)) {
    return undefined;
  }
  return Utils.structuralRegion(() => Equal.equals(a, b), (x, y) => this.equals(x, y, customTesters.filter(t => t !== customTester)));
}
/** @internal */
const addEqualityTesters = () => {
  V.expect.addEqualityTesters([customTester]);
};
/** @internal */
exports.addEqualityTesters = addEqualityTesters;
const testOptions = timeout => typeof timeout === "number" ? {
  timeout
} : timeout ?? {};
/** @internal */
const makeTester = (mapEffect, it = defaultApi) => {
  const run = (ctx, args, self) => (0, _Function.pipe)(Effect.suspend(() => self(...args)), mapEffect, runTest(ctx));
  const f = (name, self, timeout) => it(name, testOptions(timeout), ctx => run(ctx, [ctx], self));
  const skip = (name, self, timeout) => it.skip(name, testOptions(timeout), ctx => run(ctx, [ctx], self));
  const skipIf = condition => (name, self, timeout) => it.skipIf(condition)(name, testOptions(timeout), ctx => run(ctx, [ctx], self));
  const runIf = condition => (name, self, timeout) => it.runIf(condition)(name, testOptions(timeout), ctx => run(ctx, [ctx], self));
  const only = (name, self, timeout) => it.only(name, testOptions(timeout), ctx => run(ctx, [ctx], self));
  const each = cases => (name, self, timeout) => it.for(cases)(name, testOptions(timeout), (args, ctx) => run(ctx, [args], self));
  const fails = (name, self, timeout) => V.it.fails(name, testOptions(timeout), ctx => run(ctx, [ctx], self));
  const prop = (name, arbitraries, self, timeout) => {
    if (Array.isArray(arbitraries)) {
      const arbs = arbitraries.map(arbitrary => Schema.isSchema(arbitrary) ? Arbitrary.make(arbitrary) : arbitrary);
      return it(name, testOptions(timeout), ctx =>
      // @ts-ignore
      fc.assert(
      // @ts-ignore
      fc.asyncProperty(...arbs, (...as) => run(ctx, [as, ctx], self)), (0, _Predicate.isObject)(timeout) ? timeout?.fastCheck : {}));
    }
    const arbs = fc.record(Object.keys(arbitraries).reduce(function (result, key) {
      result[key] = Schema.isSchema(arbitraries[key]) ? Arbitrary.make(arbitraries[key]) : arbitraries[key];
      return result;
    }, {}));
    return it(name, testOptions(timeout), ctx =>
    // @ts-ignore
    fc.assert(fc.asyncProperty(arbs, (...as) =>
    // @ts-ignore
    run(ctx, [as[0], ctx], self)), (0, _Predicate.isObject)(timeout) ? timeout?.fastCheck : {}));
  };
  return Object.assign(f, {
    skip,
    skipIf,
    runIf,
    only,
    each,
    fails,
    prop
  });
};
/** @internal */
const prop = (name, arbitraries, self, timeout) => {
  if (Array.isArray(arbitraries)) {
    const arbs = arbitraries.map(arbitrary => Schema.isSchema(arbitrary) ? Arbitrary.make(arbitrary) : arbitrary);
    return V.it(name, testOptions(timeout),
    // @ts-ignore
    ctx => fc.assert(fc.property(...arbs, (...as) => self(as, ctx)), (0, _Predicate.isObject)(timeout) ? timeout?.fastCheck : {}));
  }
  const arbs = fc.record(Object.keys(arbitraries).reduce(function (result, key) {
    result[key] = Schema.isSchema(arbitraries[key]) ? Arbitrary.make(arbitraries[key]) : arbitraries[key];
    return result;
  }, {}));
  return V.it(name, testOptions(timeout),
  // @ts-ignore
  ctx => fc.assert(fc.property(arbs, as => self(as, ctx)), (0, _Predicate.isObject)(timeout) ? timeout?.fastCheck : {}));
};
/** @internal */
exports.prop = prop;
const layer = (layer_, options) => (...args) => {
  const excludeTestServices = options?.excludeTestServices ?? false;
  const withTestEnv = excludeTestServices ? layer_ : Layer.provideMerge(layer_, TestEnv);
  const memoMap = options?.memoMap ?? Effect.runSync(Layer.makeMemoMap);
  const scope = Effect.runSync(Scope.make());
  const runtimeEffect = Layer.toRuntimeWithMemoMap(withTestEnv, memoMap).pipe(Scope.extend(scope), Effect.orDie, Effect.cached, Effect.runSync);
  const makeIt = it => Object.assign(it, {
    effect: makeTester(effect => Effect.flatMap(runtimeEffect, runtime => effect.pipe(Effect.provide(runtime))), it),
    prop,
    scoped: makeTester(effect => Effect.flatMap(runtimeEffect, runtime => effect.pipe(Effect.scoped, Effect.provide(runtime))), it),
    flakyTest,
    layer(nestedLayer, options) {
      return layer(Layer.provideMerge(nestedLayer, withTestEnv), {
        ...options,
        memoMap,
        excludeTestServices
      });
    }
  });
  if (args.length === 1) {
    V.beforeAll(() => runPromise()(Effect.asVoid(runtimeEffect)), options?.timeout ? Duration.toMillis(options.timeout) : undefined);
    V.afterAll(() => runPromise()(Scope.close(scope, Exit.void)), options?.timeout ? Duration.toMillis(options.timeout) : undefined);
    return args[0](makeIt(defaultApi));
  }
  return V.describe(args[0], () => {
    V.beforeAll(() => runPromise()(Effect.asVoid(runtimeEffect)), options?.timeout ? Duration.toMillis(options.timeout) : undefined);
    V.afterAll(() => runPromise()(Scope.close(scope, Exit.void)), options?.timeout ? Duration.toMillis(options.timeout) : undefined);
    return args[1](makeIt(defaultApi));
  });
};
/** @internal */
exports.layer = layer;
const flakyTest = (self, timeout = Duration.seconds(30)) => (0, _Function.pipe)(Effect.catchAllDefect(self, Effect.fail), Effect.retry((0, _Function.pipe)(Schedule.recurs(10), Schedule.compose(Schedule.elapsed), Schedule.whileOutput(Duration.lessThanOrEqualTo(timeout)))), Effect.orDie);
/** @internal */
exports.flakyTest = flakyTest;
const makeMethods = it => Object.assign(it, {
  effect: makeTester(Effect.provide(TestEnv), it),
  scoped: makeTester((0, _Function.flow)(Effect.scoped, Effect.provide(TestEnv)), it),
  live: makeTester(_Function.identity, it),
  scopedLive: makeTester(Effect.scoped, it),
  flakyTest,
  layer,
  prop
});
/** @internal */
exports.makeMethods = makeMethods;
const {
  /** @internal */
  effect,
  /** @internal */
  live,
  /** @internal */
  scoped,
  /** @internal */
  scopedLive
} = /*#__PURE__*/makeMethods(defaultApi);
/** @internal */
exports.scopedLive = scopedLive;
exports.scoped = scoped;
exports.live = live;
exports.effect = effect;
const describeWrapped = (name, f) => V.describe(name, it => f(makeMethods(Object.assign(it, {
  scopedFixtures: it.scoped
}))));
exports.describeWrapped = describeWrapped;
//# sourceMappingURL=internal.js.map