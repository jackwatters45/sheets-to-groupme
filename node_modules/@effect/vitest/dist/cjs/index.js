"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  addEqualityTesters: true,
  effect: true,
  scoped: true,
  live: true,
  scopedLive: true,
  layer: true,
  flakyTest: true,
  prop: true,
  it: true,
  makeMethods: true,
  describeWrapped: true
};
exports.scopedLive = exports.scoped = exports.prop = exports.makeMethods = exports.live = exports.layer = exports.it = exports.flakyTest = exports.effect = exports.describeWrapped = exports.addEqualityTesters = void 0;
var V = _interopRequireWildcard(require("vitest"));
Object.keys(V).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === V[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return V[key];
    }
  });
});
var internal = _interopRequireWildcard(require("./internal/internal.js"));
function _interopRequireWildcard(e, t) { if ("function" == typeof WeakMap) var r = new WeakMap(), n = new WeakMap(); return (_interopRequireWildcard = function (e, t) { if (!t && e && e.__esModule) return e; var o, i, f = { __proto__: null, default: e }; if (null === e || "object" != typeof e && "function" != typeof e) return f; if (o = t ? n : r) { if (o.has(e)) return o.get(e); o.set(e, f); } for (const t in e) "default" !== t && {}.hasOwnProperty.call(e, t) && ((i = (o = Object.defineProperty) && Object.getOwnPropertyDescriptor(e, t)) && (i.get || i.set) ? o(f, t, i) : f[t] = e[t]); return f; })(e, t); }
/**
 * @since 1.0.0
 */

/**
 * @since 1.0.0
 */
const addEqualityTesters = exports.addEqualityTesters = internal.addEqualityTesters;
/**
 * @since 1.0.0
 */
const effect = exports.effect = internal.effect;
/**
 * @since 1.0.0
 */
const scoped = exports.scoped = internal.scoped;
/**
 * @since 1.0.0
 */
const live = exports.live = internal.live;
/**
 * @since 1.0.0
 */
const scopedLive = exports.scopedLive = internal.scopedLive;
/**
 * Share a `Layer` between multiple tests, optionally wrapping
 * the tests in a `describe` block if a name is provided.
 *
 * @since 1.0.0
 *
 * ```ts
 * import { expect, layer } from "@effect/vitest"
 * import { Context, Effect, Layer } from "effect"
 *
 * class Foo extends Context.Tag("Foo")<Foo, "foo">() {
 *   static Live = Layer.succeed(Foo, "foo")
 * }
 *
 * class Bar extends Context.Tag("Bar")<Bar, "bar">() {
 *   static Live = Layer.effect(
 *     Bar,
 *     Effect.map(Foo, () => "bar" as const)
 *   )
 * }
 *
 * layer(Foo.Live)("layer", (it) => {
 *   it.effect("adds context", () =>
 *     Effect.gen(function* () {
 *       const foo = yield* Foo
 *       expect(foo).toEqual("foo")
 *     })
 *   )
 *
 *   it.layer(Bar.Live)("nested", (it) => {
 *     it.effect("adds context", () =>
 *       Effect.gen(function* () {
 *         const foo = yield* Foo
 *         const bar = yield* Bar
 *         expect(foo).toEqual("foo")
 *         expect(bar).toEqual("bar")
 *       })
 *     )
 *   })
 * })
 * ```
 */
const layer = exports.layer = internal.layer;
/**
 * @since 1.0.0
 */
const flakyTest = exports.flakyTest = internal.flakyTest;
/**
 * @since 1.0.0
 */
const prop = exports.prop = internal.prop;
/**
 * @since 1.0.0
 */
/** @ignored */
const methods = {
  effect,
  live,
  flakyTest,
  scoped,
  scopedLive,
  layer,
  prop
};
/**
 * @since 1.0.0
 */
const it = exports.it = /*#__PURE__*/Object.assign(V.it, {
  ...methods,
  scopedFixtures: /*#__PURE__*/V.it.scoped.bind(V.it)
});
/**
 * @since 1.0.0
 */
const makeMethods = exports.makeMethods = internal.makeMethods;
/**
 * @since 1.0.0
 */
const describeWrapped = exports.describeWrapped = internal.describeWrapped;
//# sourceMappingURL=index.js.map